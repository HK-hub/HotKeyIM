# 一个较为完善的IM及时通讯应用的消息设计


在综合考虑对比了`轮询`，`长轮询`，`SSE+UDP/QUIC`，`WebSocket` 等一系列的用于维持聊天应用通信的方案后，最终选择了基于 `WebSocket` 的通信方式来作为我的IM应用的聊天传输协议

相对与其他而言，它具有一下比较明显的优势：
1. 全双工
2. 使用较为简单，实现复杂度低
3. 在大量连接下，性能效率更好
4. 技术支持较为完善，相关资料丰富


## 消息
## 聊天消息
用于传输，聊天中产生的各种超媒体消息数据：


| 名称        | 类名                       | 传输协议      |
|-----------|--------------------------|-----------|
| 连接初始化消息   | ConnectMessage           | WebSocket |
| 普通聊天消息    | SimpleChatMessage        | WebSocket |
| 图片聊天消息    | PictureChatMessage       | HTTP      |
| 文件/视频聊天消息 | MultipartFileChatMessage | HTTP      |
| 消息签收消息    | MessageSignedMessage     | WebSocket |
| 好友拉取消息    | FriendPullMessage        | WebSocket |
| 好友拉取消息    | FriendPullMessage        | WebSocket |




## 控制消息
## 系统消息

## text文本类型消息




## 自定义协议/二进制数据消息

## 消息ID的设计与思考
很显而易见的是我们的IM应用程序中出现最多的数据肯定是消息，无论是私聊消息，群聊消息，控制消息，系统消息，多媒体消息等，这对于我们数据库而言意味着大量的数据记录，而且会相应的出现大量的查询亲求，
这就需要我们的消息table 的主键是要符合一个高效的主键策略的，这样有助于我们InnoDB 的索引的创建，维护，以及后续查询等操作的保证。
一般意义上分布式ID的生成算法可能有：UUID策略，数据库自增，TDDL-Sequence，Leaf-Segment，雪花算法等，以及各大公司自研，修改，改进的各种算法。
但是我们的IM消息需要高效，有序存储，高效查询，这样的主键一般而言我们有一下几点很容易想到的：
1. 主键应该是数值类型
2. 主键的生成因该是分布式，全局唯一的
3. 主键应该要满足递增的特性

因为在整个IM应用中需要涉及到关于消息的发送，撤回，阅读，未读以及对于聊天记录的查看导出，会话列表的聊天内容的渲染等功能，所以在一定程度上需要我们保证消息之间的顺序问题。
这里就有很多可以参考的思路，因为我们的消息ID需要递增，分布式，全局唯一，并且根据业务需求而言，其实不仅仅是消息ID的全局唯一，其实还需要保证每个会话的消息ID是递增的，
很显然，满足这些条件的ID策略还是很多的：著名的雪花算法，以及各大公司改进的雪花算法(百度，美团)，TDDL-Sequence, 发号器算法又称为号段算法(比较有代表性的就是美团Leaf-Segment算法)。


尽管有了大致可以选择的消息ID生成算法，但是这里还需要我们进行一定的思考和修改。通常而言，对于聊天消息，消息ID可以只是简单的全局递增就好了，这样所有的会话产生的消息需要进行ID分配的时候就直接采用雪花算法及其改进算法进行分配
，但是这样存在的一个现象就是你会发现即便不是同一会话中的消息，他们的消息ID也是全局有序的，这样如果在一个IM应用中就可能存在QPS的瓶颈问题，而且对于我们IM业务中的
消息发送，接收，读取，未读，撤回等业务场景不是十分友好。

所以，为了后续未来的发展以及业务功能的拓展，往往采用在局部会话下的消息有序是较为合理的方案，换句话而言，我们只需要保证会话级别的消息有序，消息ID递增就可以解决这个聊天业务中的一个难题
。由此我们不妨就选择发号器算法(号段算法)来作为我们的消息ID生成算法。至于原因，可能有如下几点：
1. 发号器算法可以按照业务，分类等进行不同的ID生成。天然的符合我们的会话级别的ID生成，因为我们可以将每个会话都作为以一种概念上的业务。
2. 发号器算法可以保证消息ID的递增，并且是可以控制的增加，而且不存在始终回拨问题(尽管这个问题在雪花算法中以及得到了解决：具体可以参考Seta-Snowflakes)
3. 发号器算法虽然基于数据库，但是可以通过双Buffer 机制实现内存级别的分配，效率并不输雪花算法，UUID等
4. 发号器算法自己曾经实现过(可以查看我的开源项目：[ShotUrl生产器](https://github.com/HK-hub/Short-URL))
5. 市面上成熟的方案：美团Leaf-Segment 是经过检验的

当然上面只是自己的一些看法，肯定是存在比我这种粗暴的想法更加强大，完善的IM消息ID机制存在的，也欢迎各位大牛多多指点。
虽然使用了发号器算法，就能完全实现我们的IM消息ID的需求嘛？ 非常遗憾，还需要经过一系列的思考：
1. 号段起始应该设置为多少？
2. 号段步长应该多少？
3. 号段Buffer更新时机如何？
4. 更新号段，Buffer 的方式？ Version 乐观锁机制？
5. 以及有没有更加安全的方式：如果简单的通过递增，很容易暴露数据信息。能否在这短短的消息ID内加入一些有用的信息：
   1. 比如ID具备会话双方的某些信息：比如ID，账号



既然以及看过了关于消息ID的生成策略思考，那么接下来看看如何才能较为满意的实现把：

首先我们需要数据库的支持，Leaf 算法是基于数据库的：
```sql
# 会话消息ID生产器
CREATE TABLE `tb_sequence` (
   `id` BIGINT NOT NULL primary key AUTO_INCREMENT,
   `name` VARCHAR(64) NOT NULL comment '标识业务类型',
   participant_id bigint not null comment '会话参与者',
   communication_id bigint not null comment '会话发起者',
   max bigint unsigned comment '下一次将要申请的号段起始位置',
   step int default 1 comment '递增步长',
   segment int default 1000 comment '号段大小'

) ENGINE=InnoDB DEFAULT CHARSET=utf8;
create index idx_p_c on tb_sequence(participant_id, communication_id);
```

执行以上SQL 并且编写对应的实体，Mapper，Service 就可以进行操控了，但是我们想要使用该发号器还需要我们设计一些东西：
1. 提供获取id 的接口
2. 维护会话的发号器: 考虑如何存储每个会话的发号器，








